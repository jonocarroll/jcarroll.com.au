---
title: Polyglot Sorting
author: Jonathan Carroll
date: '2022-10-08'
slug: polyglot-sorting
categories:
  - R
  - python
  - julia
  - bash
  - rust
tags:
  - R
  - julia
  - python
  - bash
  - rust
type: ''
subtitle: ''
image: ''
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<p>Iâ€™ve had the impression lately that <em>everyone</em> is learning <a href="https://www.rust-lang.org/learn">Rust</a> and thereâ€™s plenty of <a href="https://github.com/joaocarvalhoopen/How_to_learn_modern_Rust">great material</a> out there to make that easier. <a href="https://github.com/r-rust/gifski">{gifski}</a> is perhaps the most well-known example of an R package wrapping a Rust Cargo crate. I donâ€™t really know any system language particularly well, so I figured Iâ€™d wade into it and see what itâ€™s like.</p>
<!--more-->
<p>Iâ€™ve had the impression lately that <em>everyone</em> is learning <a href="https://www.rust-lang.org/learn">Rust</a> and thereâ€™s plenty of <a href="https://github.com/joaocarvalhoopen/How_to_learn_modern_Rust">great material</a> out there to make that easier. <a href="https://github.com/r-rust/gifski">{gifski}</a> is perhaps the most well-known example of an R package wrapping a Rust Cargo crate. I donâ€™t really know any system language particularly well, so I figured Iâ€™d wade into it and see what itâ€™s like.</p>
<p>The big advantages Iâ€™ve heard are that itâ€™s more modern than C++, is â€œsafeâ€ (in the sense that you canâ€™t compile something that tries to read out of bounds memory), and itâ€™s super fast (itâ€™s a compiled, strictly-typed language, so one would hope so).</p>
<p>I had a browse through some beginner material, and watched some videos on Youtube. Just enough to have some understanding of the syntax and keywords so I could actually search for things once I inevitably hit problems.</p>
<p>Getting everything up and running went surprisingly smoothly. Installing <a href="https://www.rust-lang.org/tools/install">the toolchain</a> went okay on my Linux (Pop!_OS) machine, and the <a href="https://www.rust-lang.org/learn/get-started">getting started guide</a> was straightforward enough to follow along with. I soon enough had Ferris welcoming me to the world of Rust</p>
<pre><code>----------------------------
&lt; Hello fellow Rustaceans! &gt;
----------------------------
              \
               \
                 _~^~^~_
             \) /  o o  \ (/
               &#39;_   -   _&#39;
               / &#39;-----&#39; \</code></pre>
<p>Visual Studio Code works nicely as a multi-language editor, and while itâ€™s great to have errors visible to you immediately, I can imagine that gets annoying pretty quick (especially if you write as much bad Rust code as I do).</p>
<p>Next I needed to actually code something up myself. I love small, silly problems for learning - you donâ€™t know exactly what problems youâ€™ll solve along the way. This one ended up being really helpful.</p>
<p>I had <a href="https://twitter.com/somacdivad/status/1570779684702679046?s=20&amp;t=tYK7rDueMPTXSBmbjtolow">this tweet</a></p>
<blockquote class="twitter-tweet">
<p lang="en" dir="ltr">
This week Iâ€™ve been posting <a href="https://twitter.com/hashtag/Python?src=hash&amp;ref_src=twsrc%5Etfw">#Python</a> ğŸ quizzes about sorting.<br><br>Letâ€™s see if you can put everything together and solve a challenge! ğŸ’ª<a href="https://twitter.com/hashtag/CuriousAboutCode?src=hash&amp;ref_src=twsrc%5Etfw">#CuriousAboutCode</a> <a href="https://t.co/ht51eA3Ttj">pic.twitter.com/ht51eA3Ttj</a>
</p>
â€” David Amos (<span class="citation">@somacdivad</span>) <a href="https://twitter.com/somacdivad/status/1570779684702679046?ref_src=twsrc%5Etfw">September 16, 2022</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>in my bookmarks because I wanted to try to solve this with R (naturally) but I decided it was a reasonable candidate for trying to solve a problem and learn some language at the same time, so I decided to give it a go with Rust. This is slightly more complicated than an academic â€œsort some stringsâ€ because itâ€™s â€œnatural sortingâ€ (2 before 10) and has a complicating character in the middle.</p>
<p>The first step was to get Rust to read in and just print back the â€˜dataâ€™ (strings). I managed to copy some â€œprint a vector of stringsâ€ code and got that working. Iâ€™ll figure out later whatâ€™s going with the format string here</p>
<pre><code>println!(&quot;{:?}&quot;, x);</code></pre>
<p>After that, I battled errors in converting between <code>String</code>, <code>&amp;str</code>, and <code>i32</code> types; returning a <code>Result</code> (error) rather than a value; dealing with obscure errors (â€œcannot move out of borrowed contentâ€, â€œexpected named lifetime parameterâ€ - ???); and a lack of method support for a <code>struct</code> I just created (which didnâ€™t have any inherited â€˜typeâ€™). All in all, nothing too surprising given I know approximately 0 Rust, but I got there in the end!</p>
<p>Now, this wonâ€™t be anything â€œgoodâ€, but it does compile and appears to give the right answer, so Iâ€™m led to believe that means itâ€™s â€œrightâ€.</p>
<pre><code>// enable printing of the struct
#[derive(Debug)]
// create a struct with a String and an integer
// not using &amp;str due to lifetime issues
struct Pair {
    x: String,
    y: i32
}

fn main() {
    // input data vector
    let v = vec![&quot;aa-2&quot;, &quot;ab-100&quot;, &quot;aa-10&quot;, &quot;ba-25&quot;, &quot;ab-3&quot;];
    // create an accumulating vector of `Pair`s
    let mut res: Vec&lt;Pair&gt; = vec![];
    // for each string, split at &#39;-&#39;, 
    //  convert the first part to String and the second to integer.
    //  then push onto the accumulator
    for s in v {
        let a: Vec&lt;&amp;str&gt; = s.split(&quot;-&quot;).collect();
        let tmp_pair = Pair {x: a[0].to_string(), y: a[1].parse::&lt;i32&gt;().unwrap() };
        res.push(tmp_pair);
    }
    // sort by Pair.x then Pair.y
    res.sort_by_key(|k| (k.x.clone(), k.y.clone()));
    // start building a new vector for the final result
    let mut res2: Vec&lt;String&gt; = vec![];
    // paste together Pair.x, &#39;-&#39;, and Pair.y (as String)
    for s2 in res {
        res2.push(s2.x + &quot;-&quot; + &amp;s2.y.to_string());
    }

    // [&quot;aa-2&quot;, &quot;aa-10&quot;, &quot;ab-3&quot;, &quot;ab-100&quot;, &quot;ba-25&quot;]
    println!(&quot;{:?}&quot;, res2);
}</code></pre>
<p>Running</p>
<pre><code>cargo run --release</code></pre>
<p>produces the expected output</p>
<pre class="r bg-success"><code>[&quot;aa-2&quot;, &quot;aa-10&quot;, &quot;ab-3&quot;, &quot;ab-100&quot;, &quot;ba-25&quot;]</code></pre>
<p>Feel free to suggest anything that could be improved, Iâ€™m sure thereâ€™s plenty.</p>
<p>That <em>might</em> have been an okay place to stop, but I did still want to see if I could solve the problem with R, and how that might compare (in approach, readability, and speed), so I coded that up as</p>
<pre class="r"><code># input vector
s &lt;- c(&quot;aa-2&quot;, &quot;ab-100&quot;, &quot;aa-10&quot;, &quot;ba-25&quot;, &quot;ab-3&quot;)
# split into pairs of strings
x &lt;- strsplit(s, &quot;-&quot;)
# take elements of s sorted by the first elements of x then
#  the second (as integers)
s[order(sapply(x, `[[`, 1), as.integer(sapply(x, `[[`, 2)))]</code></pre>
<pre class="bg-success"><code>## [1] &quot;aa-2&quot;   &quot;aa-10&quot;  &quot;ab-3&quot;   &quot;ab-100&quot; &quot;ba-25&quot;</code></pre>
<p>I donâ€™t love that I had to use <code>sapply()</code> twice, but the only other alternative I could think of was to strip out the first and second element lists and use those in a <code>do.call()</code></p>
<pre class="r"><code>s[do.call(order, list(unlist(x)[c(T, F)], as.integer(unlist(x)[c(F,T)])))]</code></pre>
<pre class="bg-success"><code>## [1] &quot;aa-2&quot;   &quot;aa-10&quot;  &quot;ab-3&quot;   &quot;ab-100&quot; &quot;ba-25&quot;</code></pre>
<p>whichâ€¦ isnâ€™t better.</p>
<p>I also had an idea to shoehorn <code>dplyr::arrange()</code> into this, but that requires a <code>data.frame</code>. One idea I had was to read in the data, using <code>"-"</code> as a delimiter, explicitly stating that I wanted to read it as character and integer data. That seemed to work, which means I can try what I hoped</p>
<pre class="r"><code>suppressMessages(library(dplyr, quietly = TRUE))
# input vector
s &lt;- c(&quot;aa-2&quot;, &quot;ab-100&quot;, &quot;aa-10&quot;, &quot;ba-25&quot;, &quot;ab-3&quot;)

# read strings as fields delimited by &#39;-&#39;, 
#  expecting character and integer
s %&gt;% read.delim(
    text = .,
    sep = &quot;-&quot;,
    header = FALSE,
    colClasses = c(&quot;character&quot;, &quot;integer&quot;)
) %&gt;%
    # sort by first then second column
    arrange(V1, V2) %&gt;%
    # collapse to single string per row
    mutate(res = paste(V1, V2, sep = &quot;-&quot;)) %&gt;%
    pull()</code></pre>
<pre class="bg-success"><code>## [1] &quot;aa-2&quot;   &quot;aa-10&quot;  &quot;ab-3&quot;   &quot;ab-100&quot; &quot;ba-25&quot;</code></pre>
<p>Why stop there? I know other langugages! Okay, the Python and Julia examples I found in other Tweets.</p>
<p>In Julia, two options were offered. <a href="https://twitter.com/ArturoErdely/status/1570795178050584581?s=20&amp;t=tYK7rDueMPTXSBmbjtolow">This one</a></p>
<pre class="julia"><code>strings = String[&quot;aa-2&quot;, &quot;ab-100&quot;, &quot;aa-10&quot;, &quot;ba-25&quot;, &quot;ab-3&quot;];
print(join.(sort(split.(strings, &quot;-&quot;), by = x -&gt; (x[1], parse(Int, x[2]))), &quot;-&quot;))</code></pre>
<pre class="bg-success"><code>## [&quot;aa-2&quot;, &quot;aa-10&quot;, &quot;ab-3&quot;, &quot;ab-100&quot;, &quot;ba-25&quot;]</code></pre>
<p>(I added a type to the input and an explicit print), and <a href="https://twitter.com/rm_slp/status/1570931796069715969?s=20&amp;t=tYK7rDueMPTXSBmbjtolow">this one</a></p>
<pre class="julia"><code>strings = String[&quot;aa-2&quot;, &quot;ab-100&quot;, &quot;aa-10&quot;, &quot;ba-25&quot;, &quot;ab-3&quot;];
print(sort(strings, by = x-&gt;split(x, &quot;-&quot;) |&gt; v-&gt;(v[1], parse(Int, v[2]))))</code></pre>
<pre class="bg-success"><code>## [&quot;aa-2&quot;, &quot;aa-10&quot;, &quot;ab-3&quot;, &quot;ab-100&quot;, &quot;ba-25&quot;]</code></pre>
<p>The <a href="https://twitter.com/somacdivad/status/1571505932252708869?s=20&amp;t=tYK7rDueMPTXSBmbjtolow">Python example</a> offered by the original author of the challenge was</p>
<pre class="python"><code>def parts(s):
    letters, nums = s.split(&quot;-&quot;)
    return letters, int(nums)

strings = [&quot;aa-2&quot;, &quot;ab-100&quot;, &quot;aa-10&quot;, &quot;ba-25&quot;, &quot;ab-3&quot;]

print(sorted(strings, key=parts))</code></pre>
<pre class="bg-success"><code>## [&#39;aa-2&#39;, &#39;aa-10&#39;, &#39;ab-3&#39;, &#39;ab-100&#39;, &#39;ba-25&#39;]</code></pre>
<p>Lastly, I remembered that thereâ€™s a <code>sort</code> function in bash that can do natural sorting with the <code>-V</code> flag. That came together okay</p>
<pre class="bash"><code>#!/bin/bash 

v=(&quot;aa-2&quot; &quot;ab-100&quot; &quot;aa-10&quot; &quot;ba-25&quot; &quot;ab-3&quot;)
readarray -t a_out &lt; &lt;(printf &#39;%s\n&#39; &quot;${v[@]}&quot; | sort -V)
printf &#39;%s &#39; &quot;${a_out[@]}&quot;
echo 

exit 0</code></pre>
<pre class="bg-success"><code>## aa-2 aa-10 ab-3 ab-100 ba-25</code></pre>
<br />
<details>
<summary>
<tt>devtools::session_info()</tt>
</summary>
<pre class="bg-success"><code>## â”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
##  setting  value                       
##  version  R version 4.1.2 (2021-11-01)
##  os       Pop!_OS 21.04               
##  system   x86_64, linux-gnu           
##  ui       X11                         
##  language en_AU:en                    
##  collate  en_AU.UTF-8                 
##  ctype    en_AU.UTF-8                 
##  tz       Australia/Adelaide          
##  date     2022-10-08                  
## 
## â”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
##  package     * version date       lib source        
##  assertthat    0.2.1   2019-03-21 [3] CRAN (R 4.0.1)
##  blogdown      1.8     2022-02-16 [1] CRAN (R 4.1.2)
##  bookdown      0.24    2021-09-02 [1] CRAN (R 4.1.2)
##  brio          1.1.1   2021-01-20 [3] CRAN (R 4.0.3)
##  bslib         0.3.1   2021-10-06 [1] CRAN (R 4.1.2)
##  cachem        1.0.3   2021-02-04 [3] CRAN (R 4.0.3)
##  callr         3.7.0   2021-04-20 [1] CRAN (R 4.1.2)
##  cli           3.2.0   2022-02-14 [1] CRAN (R 4.1.2)
##  crayon        1.5.0   2022-02-14 [1] CRAN (R 4.1.2)
##  DBI           1.1.1   2021-01-15 [3] CRAN (R 4.0.3)
##  desc          1.4.1   2022-03-06 [1] CRAN (R 4.1.2)
##  devtools      2.4.3   2021-11-30 [1] CRAN (R 4.1.2)
##  digest        0.6.27  2020-10-24 [3] CRAN (R 4.0.3)
##  dplyr       * 1.0.8   2022-02-08 [1] CRAN (R 4.1.2)
##  ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.1.2)
##  evaluate      0.14    2019-05-28 [3] CRAN (R 4.0.1)
##  fansi         0.4.2   2021-01-15 [3] CRAN (R 4.0.3)
##  fastmap       1.1.0   2021-01-25 [3] CRAN (R 4.0.3)
##  fs            1.5.0   2020-07-31 [3] CRAN (R 4.0.2)
##  generics      0.1.0   2020-10-31 [3] CRAN (R 4.0.3)
##  glue          1.6.1   2022-01-22 [1] CRAN (R 4.1.2)
##  here          1.0.1   2020-12-13 [1] CRAN (R 4.1.2)
##  htmltools     0.5.2   2021-08-25 [1] CRAN (R 4.1.2)
##  jquerylib     0.1.4   2021-04-26 [1] CRAN (R 4.1.2)
##  jsonlite      1.7.2   2020-12-09 [3] CRAN (R 4.0.3)
##  JuliaCall     0.17.4  2021-05-16 [1] CRAN (R 4.1.2)
##  knitr         1.37    2021-12-16 [1] CRAN (R 4.1.2)
##  lattice       0.20-41 2020-04-02 [4] CRAN (R 4.0.0)
##  lifecycle     1.0.1   2021-09-24 [1] CRAN (R 4.1.2)
##  magrittr      2.0.1   2020-11-17 [3] CRAN (R 4.0.3)
##  Matrix        1.3-2   2021-01-06 [4] CRAN (R 4.0.4)
##  memoise       2.0.0   2021-01-26 [3] CRAN (R 4.0.3)
##  pillar        1.7.0   2022-02-01 [1] CRAN (R 4.1.2)
##  pkgbuild      1.2.0   2020-12-15 [3] CRAN (R 4.0.3)
##  pkgconfig     2.0.3   2019-09-22 [3] CRAN (R 4.0.1)
##  pkgload       1.2.4   2021-11-30 [1] CRAN (R 4.1.2)
##  png           0.1-7   2013-12-03 [3] CRAN (R 4.0.2)
##  prettyunits   1.1.1   2020-01-24 [3] CRAN (R 4.0.1)
##  processx      3.5.2   2021-04-30 [1] CRAN (R 4.1.2)
##  ps            1.5.0   2020-12-05 [3] CRAN (R 4.0.3)
##  purrr         0.3.4   2020-04-17 [3] CRAN (R 4.0.1)
##  R6            2.5.0   2020-10-28 [3] CRAN (R 4.0.2)
##  Rcpp          1.0.9   2022-07-08 [1] CRAN (R 4.1.2)
##  remotes       2.4.2   2021-11-30 [1] CRAN (R 4.1.2)
##  reticulate    1.24    2022-01-26 [1] CRAN (R 4.1.2)
##  rlang         1.0.1   2022-02-03 [1] CRAN (R 4.1.2)
##  rmarkdown     2.13    2022-03-10 [1] CRAN (R 4.1.2)
##  rprojroot     2.0.2   2020-11-15 [3] CRAN (R 4.0.3)
##  rstudioapi    0.13    2020-11-12 [3] CRAN (R 4.0.3)
##  sass          0.4.0   2021-05-12 [1] CRAN (R 4.1.2)
##  sessioninfo   1.1.1   2018-11-05 [3] CRAN (R 4.0.1)
##  stringi       1.5.3   2020-09-09 [3] CRAN (R 4.0.2)
##  stringr       1.4.0   2019-02-10 [3] CRAN (R 4.0.1)
##  testthat      3.1.2   2022-01-20 [1] CRAN (R 4.1.2)
##  tibble        3.1.6   2021-11-07 [1] CRAN (R 4.1.2)
##  tidyselect    1.1.2   2022-02-21 [1] CRAN (R 4.1.2)
##  usethis       2.1.5   2021-12-09 [1] CRAN (R 4.1.2)
##  utf8          1.1.4   2018-05-24 [3] CRAN (R 4.0.2)
##  vctrs         0.3.8   2021-04-29 [1] CRAN (R 4.1.2)
##  withr         2.5.0   2022-03-03 [1] CRAN (R 4.1.2)
##  xfun          0.30    2022-03-02 [1] CRAN (R 4.1.2)
##  yaml          2.2.1   2020-02-01 [3] CRAN (R 4.0.1)
## 
## [1] /home/jono/R/x86_64-pc-linux-gnu-library/4.1
## [2] /usr/local/lib/R/site-library
## [3] /usr/lib/R/site-library
## [4] /usr/lib/R/library</code></pre>
</details>
<p><br /></p>
