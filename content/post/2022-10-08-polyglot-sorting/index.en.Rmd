---
title: Polyglot Sorting
author: Jonathan Carroll
date: '2022-10-08'
slug: polyglot-sorting
categories:
  - R
  - python
  - julia
  - bash
  - rust
tags:
  - R
  - julia
  - python
  - bash
  - rust
type: ''
subtitle: ''
image: ''
---

```{r, setup, include = FALSE}
library(dplyr)

knitr::opts_chunk$set(
  class.output  = "bg-success",
  class.message = "bg-info text-info",
  class.warning = "bg-warning text-warning",
  class.error   = "bg-danger text-danger"
)
```

I've had the impression lately that *everyone* is learning [Rust](https://www.rust-lang.org/learn) and there's plenty of [great material](https://github.com/joaocarvalhoopen/How_to_learn_modern_Rust) out there to make that easier. [{gifski}](https://github.com/r-rust/gifski) is perhaps the most well-known example of an R package wrapping a Rust Cargo crate. I don't really know any system language particularly well, so I figured I'd wade into it and see what it's like.

<!--more-->

I've had the impression lately that *everyone* is learning [Rust](https://www.rust-lang.org/learn) and there's plenty of [great material](https://github.com/joaocarvalhoopen/How_to_learn_modern_Rust) out there to make that easier. [{gifski}](https://github.com/r-rust/gifski) is perhaps the most well-known example of an R package wrapping a Rust Cargo crate. I don't really know any system language particularly well, so I figured I'd wade into it and see what it's like.

The big advantages I've heard are that it's more modern than C++, is "safe" (in the sense that you can't compile something that tries to read out of bounds memory), and it's super fast (it's a compiled, strictly-typed language, so one would hope so).

I had a browse through some beginner material, and watched some videos on Youtube. Just enough to have some understanding of the syntax and keywords so I could actually search for things once I inevitably hit problems.

Getting everything up and running went surprisingly smoothly. Installing [the toolchain](https://www.rust-lang.org/tools/install) went okay on my Linux (Pop!_OS) machine, and the [getting started guide](https://www.rust-lang.org/learn/get-started) was straightforward enough to follow along with. I soon enough had Ferris welcoming me to the world of Rust

```
----------------------------
< Hello fellow Rustaceans! >
----------------------------
              \
               \
                 _~^~^~_
             \) /  o o  \ (/
               '_   -   _'
               / '-----' \
```

Visual Studio Code works nicely as a multi-language editor, and while it's great to have errors visible to you immediately, I can imagine that gets annoying pretty quick (especially if you write as much bad Rust code as I do).

Next I needed to actually code something up myself. I love small, silly problems for learning - you don't know exactly what problems you'll solve along the way. This one ended up being really helpful.

I had [this tweet](https://twitter.com/somacdivad/status/1570779684702679046?s=20&t=tYK7rDueMPTXSBmbjtolow)

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">This week I‚Äôve been posting <a href="https://twitter.com/hashtag/Python?src=hash&amp;ref_src=twsrc%5Etfw">#Python</a> üêç quizzes about sorting.<br><br>Let‚Äôs see if you can put everything together and solve a challenge! üí™<a href="https://twitter.com/hashtag/CuriousAboutCode?src=hash&amp;ref_src=twsrc%5Etfw">#CuriousAboutCode</a> <a href="https://t.co/ht51eA3Ttj">pic.twitter.com/ht51eA3Ttj</a></p>&mdash; David Amos (@somacdivad) <a href="https://twitter.com/somacdivad/status/1570779684702679046?ref_src=twsrc%5Etfw">September 16, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

in my bookmarks because I wanted to try to solve this with R (naturally) but I decided it was a reasonable candidate for trying to solve a problem and learn some language at the same time, so I decided to give it a go with Rust. This is slightly more complicated than an academic "sort some strings" because it's "natural sorting" (2 before 10) and has a complicating character in the middle.

The first step was to get Rust to read in and just print back the 'data' (strings). I managed to copy some "print a vector of strings" code and got that working. I'll figure out later what's going with the format string here

```
println!("{:?}", x);
```

After that, I battled errors in converting between `String`, `&str`, and `i32` types; returning a `Result` (error) rather than a value; dealing with obscure errors ("cannot move out of borrowed content", "expected named lifetime parameter" - ???); and a lack of method support for a `struct` I just created (which didn't have any inherited 'type'). All in all, nothing too surprising given I know approximately 0 Rust, but I got there in the end!

Now, this won't be anything "good", but it does compile and appears to give the right answer, so I'm led to believe that means it's "right".

```
// enable printing of the struct
#[derive(Debug)]
// create a struct with a String and an integer
// not using &str due to lifetime issues
struct Pair {
    x: String,
    y: i32
}

fn main() {
    // input data vector
    let v = vec!["aa-2", "ab-100", "aa-10", "ba-25", "ab-3"];
    // create an accumulating vector of `Pair`s
    let mut res: Vec<Pair> = vec![];
    // for each string, split at '-', 
    //  convert the first part to String and the second to integer.
    //  then push onto the accumulator
    for s in v {
        let a: Vec<&str> = s.split("-").collect();
        let tmp_pair = Pair {x: a[0].to_string(), y: a[1].parse::<i32>().unwrap() };
        res.push(tmp_pair);
    }
    // sort by Pair.x then Pair.y
    res.sort_by_key(|k| (k.x.clone(), k.y.clone()));
    // start building a new vector for the final result
    let mut res2: Vec<String> = vec![];
    // paste together Pair.x, '-', and Pair.y (as String)
    for s2 in res {
        res2.push(s2.x + "-" + &s2.y.to_string());
    }

    // ["aa-2", "aa-10", "ab-3", "ab-100", "ba-25"]
    println!("{:?}", res2);
}
```

Running

```
cargo run --release
```
produces the expected output

```{R, class.source = "bg-success", eval = FALSE}
["aa-2", "aa-10", "ab-3", "ab-100", "ba-25"]
```

Feel free to suggest anything that could be improved, I'm sure there's plenty.

That _might_ have been an okay place to stop, but I did still want to see if I could solve the problem with R, and how that might compare (in approach, readability, and speed), so I coded that up as

```{r}
# input vector
s <- c("aa-2", "ab-100", "aa-10", "ba-25", "ab-3")
# split into pairs of strings
x <- strsplit(s, "-")
# take elements of s sorted by the first elements of x then
#  the second (as integers)
s[order(sapply(x, `[[`, 1), as.integer(sapply(x, `[[`, 2)))]
```

I don't love that I had to use `sapply()` twice, but the only other alternative I could think of was to strip out the first and second element lists and use those in a `do.call()`

```{r}
s[do.call(order, list(unlist(x)[c(T, F)], as.integer(unlist(x)[c(F,T)])))]
```
which... isn't better.

I also had an idea to shoehorn `dplyr::arrange()` into this, but that requires a `data.frame`. One idea I had was to read in the data, using `"-"` as a delimiter, explicitly stating that I wanted to read it as character and integer data. That seemed to work, which means I can try what I hoped

```{r}
suppressMessages(library(dplyr, quietly = TRUE))
# input vector
s <- c("aa-2", "ab-100", "aa-10", "ba-25", "ab-3")

# read strings as fields delimited by '-', 
#  expecting character and integer
s %>% read.delim(
    text = .,
    sep = "-",
    header = FALSE,
    colClasses = c("character", "integer")
) %>%
    # sort by first then second column
    arrange(V1, V2) %>%
    # collapse to single string per row
    mutate(res = paste(V1, V2, sep = "-")) %>%
    pull()
```

Why stop there? I know other langugages! Okay, the Python and Julia examples I found in other Tweets.

In Julia, two options were offered. [This one](https://twitter.com/ArturoErdely/status/1570795178050584581?s=20&t=tYK7rDueMPTXSBmbjtolow)

```{julia}
strings = String["aa-2", "ab-100", "aa-10", "ba-25", "ab-3"];
print(join.(sort(split.(strings, "-"), by = x -> (x[1], parse(Int, x[2]))), "-"))
```

(I added a type to the input and an explicit print), and [this one](https://twitter.com/rm_slp/status/1570931796069715969?s=20&t=tYK7rDueMPTXSBmbjtolow)

```{julia}
strings = String["aa-2", "ab-100", "aa-10", "ba-25", "ab-3"];
print(sort(strings, by = x->split(x, "-") |> v->(v[1], parse(Int, v[2]))))
```

The [Python example](https://twitter.com/somacdivad/status/1571505932252708869?s=20&t=tYK7rDueMPTXSBmbjtolow) offered by the original author of the challenge was

```{python}
def parts(s):
    letters, nums = s.split("-")
    return letters, int(nums)

strings = ["aa-2", "ab-100", "aa-10", "ba-25", "ab-3"]

print(sorted(strings, key=parts))
```

Lastly, I remembered that there's a `sort` function in bash that can do natural sorting with the `-V` flag. That came together okay

```{bash}
#!/bin/bash 

v=("aa-2" "ab-100" "aa-10" "ba-25" "ab-3")
readarray -t a_out < <(printf '%s\n' "${v[@]}" | sort -V)
printf '%s ' "${a_out[@]}"
echo 

exit 0
```

<br />
<details>
  <summary>
    <tt>devtools::session_info()</tt>
  </summary>
```{r sessionInfo, echo = FALSE}
devtools::session_info()
```
</details>
<br />
